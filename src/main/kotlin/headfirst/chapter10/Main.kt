package headfirst.chapter10

/** Создание функции, возвращающей обобщенный тип */
fun getPets(breed: String): MutableList<Pet> {
    //Получение объектов Duck нужного вида
    return mutableListOf(Pet("Donald"))
}

/** Создание класса с ограниченным типом.
    Инвариантный тип может принимать ссылки только этого конкретного типа. */
class Zoo<T : Pet>

/** Создание функции, получающей обобщенный тип */
fun printAnimals(pets: MutableList<Pet>) {
    for (animal in pets) {
        animal.type()
    }
}

fun main(args: Array<String>) {

    /** Создание экземпляра обобщенного класса */
    val petList: MutableList<Pet>
    petList = mutableListOf(Pet("Duck"), Pet("Fish"), Pet("Dog"))
    printAnimals(petList)
}

/** Ковариантный обобщенный тип. Это означает, что можно использовать подтип вместо супертипа. */
interface Retailer<out T> {
    fun sell(): T
}

/** Ковариантный тип не может использоваться в качестве типа переменной или параметра функции. */
interface A<out T> {
    // не компилируется
    // var y: T
    // fun myFunction(t: T)
}

/** Контрвариантный тип означает, что можно использовать супертип вместо подтипа (родительские классы T).
    Контрвариантность противоположна ковариантности.
    Обобщенный тип с префиксом in может использоваться только во «входных» позициях — скажем, в значении
    параметра функции. Он не может использоваться в «выходных» позициях.*/
interface B<in T> {
}